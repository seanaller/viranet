###############################################################################
# analysis.py performs analysis on the host-virus integrated model (HVM)
# generated by the "viranet.generation.py" sub-module for: comparison of states;
# effect of knockouts; effects of host-derived constraints
###############################################################################
# Sean Aller: 2016 05 23
# S-D.Aller@warwick.ac.uk
###############################################################################
# Setup of workspace
import  cobra
from    cobra           import Model, Reaction, Metabolite
import  numpy           as np
import  pandas          as pd
import  string
from    viranet         import tools
from    viranet.info    import metDict, aaMets, ntpsMets

###############################################################################
# optimise
# Optimises the HVM for host and virus optimal states
# Inputs:
# HVM               Integrated host-virus model
# HostRxn           Host objective reaction, either:
#                   - Index value of reaction in Model.reactions        [int]
#                   - Reaction ID of the host-objective reaction        [str]
# solver            [OPTIONAL] Declare solver to use for cobrapy: default is cglpk
#
# Outputs:
# objIdx            Index value for the objective reactions
# hostF             Host-objective optima value
# hostX             Vector of non-objective reaction fluxes for host-optimised
# virusF            Virus-objective optima value
# virusX            Vector of non-objective reaction fluxes for virus-optimised
#
def optimise(HVM,HostRxn,solver='cglpk'):
    "Optimise HVM"
    # [1] Initial Setup
    # Identify the host objective reaction
    try:
        intTest = int(HostRxn)
        hostIdx = HostRxn
    except:
        for ii in range(len(HVM.reactions)):
            if HostRxn in str(HVM.reactions[ii]):
                hostIdx = ii
    virusIdx    = len(HVM.reactions) - 1    # ViraNet(c) appends virus reaction to end in genHVM.py
    objIdx      = [hostIdx,virusIdx]
    # [2] State Optimisations
    # Identify the reactions
    hostObj     = HVM.reactions[hostIdx]
    virusObj    = HVM.reactions[virusIdx]
    # Record the bounds
    hostLb      = HVM.reactions[hostIdx].lower_bound
    hostUb      = HVM.reactions[hostIdx].upper_bound
    virusLb     = HVM.reactions[virusIdx].lower_bound
    virusUb     = HVM.reactions[virusIdx].upper_bound
    # Host optimisation
    HVM.change_objective(hostObj)
    # Zero-bound virus reaction
    HVM.reactions[virusIdx].lower_bound = 0
    HVM.reactions[virusIdx].upper_bound = 0
    # Record Optima
    hostSol     = HVM.optimize(objective_sense='maximize',solver=solver)
    hostX       = hostSol.x                 # Host-optimal flux vector
    hostF       = hostSol.f                 # Optima value for host objective
    # Return virus reaction to correct bounds
    HVM.reactions[virusIdx].lower_bound = virusLb
    HVM.reactions[virusIdx].upper_bound = virusUb
    # Virus optimisation
    # Check that virus objective is correct and generated from 'generation.py'
    if '_prodrxn_VN' in virusObj.id:
        # Zero-bound host reaction
        HVM.reactions[hostIdx].lower_bound = 0
        HVM.reactions[hostIdx].upper_bound = 0
        # Record virus optima
        HVM.change_objective(virusObj)
        virusSol    = HVM.optimize(objective_sense='maximize',solver=solver)
        virusX      = virusSol.x                # Virus-optimal flux vector
        virusF      = virusSol.f                # Optima value for virus objective
        # Return virus reaction to correct bounds
        HVM.reactions[hostIdx].lower_bound = hostLb
        HVM.reactions[hostIdx].upper_bound = hostUb
    else:
        raise ValueError('Unsupported objective, unable to analyse: refer to README')
    # [3] Outputs
    return (objIdx, hostF, hostX, virusF, virusX)
###############################################################################

###############################################################################
# differential
# Compares the host and virus objective functions for amino acid and nucleotide
# usage
# Inputs:
# HVM               Integrated host-virus model
# HostRxn           Host objective reaction, either:
#                   - Index value of reaction in Model.reactions        [int]
#                   - Reaction ID of the host-objective reaction        [str]
#
# Outputs:
# rel_difAA,        Relative differential comparison of amino acid and nucleotide
# rel_difNT         usage in the host and virus objective functions
#                   [Relative comparison: amino acids are only considered within
#                   the amino acid fraction; nucleotides are only considered
#                   within the nucleotide fraction]
# abs_difAA,        Absolute differential comparison of amino acid and nucleotide
# abs_difNT         usage in the host and virus objective functions
#                   [Absolute comparison: amino acids and nucleotides are
#                   considered against all macromolecular fractions]
#
def differential(HVM,HostRxn):
    "Differential usage of amino acids and nucleotides"
    # [1] Initial Setup
    # Identify the host objective reaction
    try:
        intTest = int(HostRxn)
        hostIdx = HostRxn
    except:
        for ii in range(len(HVM.reactions)):
            if HostRxn in str(HVM.reactions[ii]):
                hostIdx = ii
    virusIdx    = len(HVM.reactions) - 1    # ViraNet(c) appends virus reaction to end in genHVM.py
    objIdx      = [hostIdx,virusIdx]
    hostID      = HVM.reactions[hostIdx].id
    virusID     = HVM.reactions[virusIdx].id
    # Condition: ensure virus reaction is virus objective
    if '_prodrxn_VN' not in virusID:
        raise ValueError('Unsupported objective, unable to analyse: refer to README')
    # Convert model into an array
    m       = HVM.to_array_based_model()
    # Create data frame
    mFrame  = pd.DataFrame(
        data    = m.S.todense(),
        columns = m.reactions.list_attr("id"),
        index   = m.metabolites.list_attr("id")
    )
    # [2] Differential usage analysis
    # Strip the host and virus objective function stoichiometric coefficients
    hostS   = mFrame[hostID]
    virusS  = mFrame[virusID]
    # Storage variable creation
    hostAA  = np.zeros((20,1))
    hostNT  = np.zeros((4,1))
    virusAA = np.zeros((20,1))
    virusNT = np.zeros((4,1))
    # Loop and collect the stoichiometric coefficients
    # Amino acids
    for ii in range(len(aaMets)):
        hostAA[ii]  = np.absolute(hostS[metDict[aaMets[ii]]])
        virusAA[ii] = np.absolute(virusS[metDict[aaMets[ii]]])
    # Nucleotides
    for ii in range(len(ntpsMets)):
        if (hostS[metDict['ctp']]) > 0:
            hostNT[ii]  = np.absolute(hostS[metDict[ntpsMets[ii]]])
        else:
            oldMet      = metDict[ntpsMets[ii]]
            tempMet     = oldMet.replace('tp','mp')
            hostNT[ii]  = np.absolute(hostS[tempMet])
        if ntpsMets[ii] is not "atp":
            virusNT[ii] = np.absolute(virusS[metDict[ntpsMets[ii]]])
        else:
            virusNT[ii] = np.absolute(virusS[metDict[ntpsMets[ii]]]) - np.absolute(virusS[metDict['adp']])
        # [3] Create output
        # Dictionary to hold metabolites with corresponding values
        rel_dif = dict()
        abs_dif = dict()
        # Relative difference
        for ii in range(len(aaMets)):
            rdifH  = hostAA[ii] / np.sum(hostAA)
            rdifV  = virusAA[ii] / np.sum(virusAA)
            rdifX  = (rdifV / rdifH) - 1
            rdifX  = rdifX.tolist()
            rdifX  = rdifX[0]
            rel_dif[aaMets[ii]] = rdifX
        for ii in range(len(ntpsMets)):
            rdifH  = hostNT[ii] / np.sum(hostNT)
            rdifV  = virusNT[ii] / np.sum(virusNT)
            rdifX  = (rdifV / rdifH) - 1
            rdifX  = rdifX.tolist()
            rdifX  = rdifX[0]
            rel_dif[ntpsMets[ii]] = rdifX
        # Absolute difference
        for ii in range(len(aaMets)):
            adifH  = hostAA[ii] / np.sum(hostS)
            adifV  = virusAA[ii] / np.sum(virusS)
            adifX  = (adifV / adifH) - 1
            adifX  = adifX.tolist()
            adifX  = adifX[0]
            abs_dif[aaMets[ii]] = adifX
        for ii in range(len(ntpsMets)):
            adifH  = hostNT[ii] / np.sum(hostS)
            adifV  = virusNT[ii] / np.sum(virusS)
            adifX  = (adifV / adifH) - 1
            adifX  = adifX.tolist()
            adifX  = adifX[0]
            abs_dif[ntpsMets[ii]] = adifX
    # Return values
    return(rel_dif, abs_dif)
###############################################################################

###############################################################################
# compare
# Compares the flux distribution of a host-optimal state with that of a virus-
# optimal state
# Inputs:
# objIdx            Index value for the objective reactions
# hostX             Vector of non-objective reaction fluxes for host-optimised
# virusX            Vector of non-objective reaction fluxes for virus-optimised
#
# Outputs:
# hvmComp           Comparison of HOS and VOS flux values (as % total flux)
# hvmStat           Reaction stats for HOS and VOS states:
#                   - Upregulated
#                   - Downregulated
#                   - Activated
#                   - Inactivated
#                   - Reversed

def compare(objIdx,hostX,virusX):
    "Host-Virus Comparison"
    # [1] Initial Setup
    # Numpy Conversion
    hostX   = np.array(hostX)
    virusX  = np.array(virusX)
    # Remove the objective reactions from both flux vectors
    hostXd  = np.delete(hostX,objIdx)
    virusXd = np.delete(virusX,objIdx)
    # Convert flux vectors to absolute and normalise to summation of vector
    pHOS    = (hostXd / sum(np.absolute(hostX))) * 100
    pVOS    = (virusXd / sum(np.absolute(virusX))) * 100
    # Convert to suitable numpy array
    pHOS    = np.array(pHOS)
    pVOS    = np.array(pVOS)
    # [2] Reaction Statistics
    # Variables for calculations
    tol     = 1.05                                          # Regulated tolerance
    e       = 1e-06                                         # Threshold for 'on'
    ne      = e * -1                                        # Negative threshold
    inf     = np.inf
    # Reaction states: Upregulated; Downregulated; Activated; Inactivated; Reversed
    urRxns = 0
    drRxns = 0
    avRxns = 0
    iaRxns = 0
    reRxns = 0
    # Initiate loop
    for ii in range(len(pHOS)):
        # Upregulated
        if (pVOS[ii] > e) and (pHOS[ii] > e) and ((pVOS[ii] / pHOS[ii]) > tol) and ((pVOS[ii] / pHOS[ii]) < inf):
            urRxns += 1
        elif (pVOS[ii] < ne) and (pHOS[ii] < ne) and ((pVOS[ii] / pHOS[ii]) > tol) and ((pVOS[ii] / pHOS[ii]) < inf):
            urRxns += 1
        # Downregulated
        if (pVOS[ii] > e) and (pHOS[ii] > e) and ((pHOS[ii] / pVOS[ii]) > tol) and ((pHOS[ii] / pVOS[ii]) < inf):
            drRxns += 1
        elif (pVOS[ii] < ne) and (pHOS[ii] < ne) and ((pHOS[ii] / pVOS[ii]) > tol) and ((pHOS[ii] / pVOS[ii]) < inf):
            drRxns += 1
        # Activated
        if (np.absolute(pVOS[ii]) > e) and (np.absolute(pHOS[ii]) < e):
            avRxns += 1
        # Inactivated
        if (np.absolute(pVOS[ii]) < e) and (np.absolute(pHOS[ii]) > e):
            iaRxns += 1
        # Reversed
        if (pVOS[ii] > e and pHOS[ii] < ne) or (pVOS[ii] < ne and pHOS[ii] > e):
            reRxns +=1
    # [3] Outputs
    # hvmComp
    hvmComp     = np.vstack((pHOS,pVOS))
    hvmComp     = hvmComp.transpose()
    # hvmStat
    hvmStat     = [urRxns,drRxns,avRxns,iaRxns,reRxns]

    return(hvmComp,hvmStat,hostXd,virusXd)
###############################################################################

###############################################################################
# varability
# Optimises the HVM for host and virus optimal states, using flux variability 
# analysis
# Inputs:
# HVM               Integrated host-virus model
# HostRxn           Host objective reaction, either:
#                   - Index value of reaction in Model.reactions        [int]
#                   - Reaction ID of the host-objective reaction        [str]
# Optional Inputs
# solver            Declare solver to use for cobrapy: default is cglpk
#
# Outputs:
# hostFVA           Vector of non-objective reaction fluxes for host-optimised  [maximum | minimum]
# virusFVA          Vector of non-objective reaction fluxes for virus-optimised [maximum | minimum]
#
def variability(HVM,HostRxn,solver='cglpk'):
    "Variability of HVM"
    # [1] Initial Setup
    # Identify the host objective reaction
    try:
        intTest = int(HostRxn)
        hostIdx = HostRxn
    except:
        for ii in range(len(HVM.reactions)):
            if HostRxn in str(HVM.reactions[ii]):
                hostIdx = ii
    virusIdx    = len(HVM.reactions) - 1    # ViraNet(c) appends virus reaction to end in genHVM.py
    objIdx      = [hostIdx,virusIdx]
    # [2] State Optimisations
    ######
    # Host optimisation #
    hostObj     = HVM.reactions[hostIdx]
    HVM.change_objective(hostObj)
    # Ensure no flux can go through the virus reaction
    # Store the bounds
    virusLb     = HVM.reactions[virusIdx].lower_bound
    virusUb     = HVM.reactions[virusIdx].upper_bound
    HVM.reactions[virusIdx].lower_bound = 0
    HVM.reactions[virusIdx].upper_bound = 0
    # FVA
    varHost     = cobra.flux_analysis.flux_variability_analysis(HVM,solver=solver)
    # Return virus objective bounds
    HVM.reactions[virusIdx].lower_bound = virusLb
    HVM.reactions[virusIdx].upper_bound = virusUb
    ######
    # Virus optimisation #
    virusObj    = HVM.reactions[virusIdx]
    # Check that virus objective is correct and generated from 'generation.py'
    if '_prodrxn_VN' in virusObj.id:
        HVM.change_objective(virusObj)
        # Ensure no flux can go through the host reaction
        # Store the bounds
        hostLb      = HVM.reactions[hostIdx].lower_bound
        hostUb      = HVM.reactions[hostIdx].upper_bound
        HVM.reactions[hostIdx].lower_bound = 0
        HVM.reactions[hostIdx].upper_bound = 0
        # FVA
        varVirus    = cobra.flux_analysis.flux_variability_analysis(HVM,solver=solver)
        # Return host objective bounds
        HVM.reactions[hostIdx].lower_bound = hostLb
        HVM.reactions[hostIdx].upper_bound = hostUb
    else:
        raise ValueError('Unsupported objective, unable to analyse: refer to README')
    ######
    # [3] Outputs
    # Create of data frames
    hostFVA   = pd.DataFrame.from_dict(varHost)
    hostFVA   = hostFVA.transpose()
    virusFVA  = pd.DataFrame.from_dict(varVirus)
    virusFVA  = virusFVA.transpose()
    # Return
    return (hostFVA, virusFVA)

###############################################################################

###############################################################################
# knockout
# Analysis of the effect of a single-reaction knockout on virus production
# Inputs:
# HVM               Integrated host-virus model
# solver            [OPTIONAL] Declare solver to use for cobrapy: default is cglpk
#
# Outputs:
# koVirus          Vector of virus optima values for single-reaction knockout

def knockout(HVM,HostRxn,solver='cglpk'):
    "Reaction Knockouts"
    # [1] Initial Setup
    # Identify the host objective reaction
    try:
        intTest = int(HostRxn)
        hostIdx = HostRxn
    except:
        for ii in range(len(HVM.reactions)):
            if HostRxn in str(HVM.reactions[ii]):
                hostIdx = ii
    # Ensure virus is objective
    HVM.change_objective(HVM.reactions[-1])
    # Variable creation to hold virus optima
    koVirus     = np.zeros((len(HVM.reactions),1))
    # [2] Knockout Analysis
    # Record the host bounds
    hostLb      = HVM.reactions[hostIdx].lower_bound
    hostUb      = HVM.reactions[hostIdx].upper_bound
    # Initiate loop
    for ii in range(len(HVM.reactions)):
        # Store the bounds of the reaction [ii]
        rxnLb = HVM.reactions[ii].lower_bound
        rxnUb = HVM.reactions[ii].upper_bound
        # Alter bounds to zero
        HVM.reactions[ii].lower_bound = 0
        HVM.reactions[ii].upper_bound = 0
        # Ensure the host objective is set to zero bounds
        HVM.reactions[hostIdx].lower_bound = 0
        HVM.reactions[hostIdx].upper_bound = 0
        # Record and store the virus optima
        vSol = HVM.optimize(objective_sense='maximize',solver=solver)
        koVirus[ii] = vSol.f
        # Return reaction [ii] to it's original bounds
        HVM.reactions[ii].lower_bound = rxnLb
        HVM.reactions[ii].upper_bound = rxnUb
    # Return host bounds to original
    HVM.reactions[hostIdx].lower_bound = hostLb
    HVM.reactions[hostIdx].upper_bound = hostUb
    # [3] Outputs
    return koVirus
###############################################################################

###############################################################################
# enforcement
# Analysis of the effect of a single-reaction host-derived constraint enforced
# for a virus-optimised system
# Inputs:
# HVM               Integrated host-virus model
# hostX             Vector of non-objective reaction fluxes for host-optimised
# Optional Inputs
# solver            Declare solver to use for cobrapy: default is cglpk
# usefva            Use the Host FBA result (False) or use the FVA range as
#                   the additional constraint (True)
# userange          Use the Host FVA results for enforcement analysis, either the
#                   median FVA value for both bounds (False) or the min / max FVA
#                   as the reaction bounds (True) 
# HostRxn           Host objective reaction, either:
#                   - Index value of reaction in Model.reactions        [int]
#                   - Reaction ID of the host-objective reaction        [str]           
# Outputs:
# enfVirus          Vector of virus optima values with additional host-constraint
# Optional Outputs:
# maxEnfBound       Maximum enf bound
# minEnfBound       Minimum enf bound

def enforce(HVM,hostX,HostRxn,solver='cglpk',usefva=False,userange=False):
    "Host-derived Enforcement"
    # [1] Initial Setup
    # Identify virus reaction
    virusIdx    = len(HVM.reactions) - 1    # ViraNet(c) appends virus reaction to end in genHVM.py
    virusObj    = HVM.reactions[virusIdx]
    # FVA Conditional
    if usefva == False:
        # Ensure virus is objective
        HVM.change_objective(HVM.reactions[-1])
        # Numpy Conversion
        hostX   = np.array(hostX)
    elif usefva == True:
        # Ensure host is objective
        # Identify the host objective reaction
        try:
            intTest = int(HostRxn)
            hostIdx = HostRxn
        except:
            for ii in range(len(HVM.reactions)):
                if HostRxn in str(HVM.reactions[ii]):
                    hostIdx = ii
        hostObj     = HVM.reactions[hostIdx]
        HVM.change_objective(hostObj)
        # Record the bounds
        hostLb      = HVM.reactions[hostIdx].lower_bound
        hostUb      = HVM.reactions[hostIdx].upper_bound
        virusLb     = HVM.reactions[virusIdx].lower_bound
        virusUb     = HVM.reactions[virusIdx].upper_bound
        # Host optimisation
        HVM.change_objective(hostObj)
        # Zero-bound virus reaction
        HVM.reactions[virusIdx].lower_bound = 0
        HVM.reactions[virusIdx].upper_bound = 0
        # Perform flux varability analysis
        varHost     = cobra.flux_analysis.flux_variability_analysis(HVM,solver=solver)
        # Return virus reaction to correct bounds
        HVM.reactions[virusIdx].lower_bound = virusLb
        HVM.reactions[virusIdx].upper_bound = virusUb
    # Variable creation to hold virus optima
    HVM.change_objective(virusObj)
    enfVirus    = np.zeros((len(hostX),1))
    # [2] Enforcement Analysis
    # Initiate loop
    #####################################
    # USEFVA #
    # False conditional
    if usefva == False:
        # Record the host bounds
        hostLb      = HVM.reactions[hostIdx].lower_bound
        hostUb      = HVM.reactions[hostIdx].upper_bound
        # Initiate loop
        for ii in range(len(HVM.reactions)):
            # Store the bounds of the reaction [ii]
            rxnLb = HVM.reactions[ii].lower_bound
            rxnUb = HVM.reactions[ii].upper_bound
            # Ensure the host objective is set to zero bounds
            HVM.reactions[hostIdx].lower_bound = 0
            HVM.reactions[hostIdx].upper_bound = 0
            # Alter reacton [ii] bounds to match host-derived flux: hostX[ii]
            HVM.reactions[ii].lower_bound = hostX[ii]
            HVM.reactions[ii].upper_bound = hostX[ii]
            # Record and store the virus optima
            vSol = HVM.optimize(objective_sense='maximize',solver=solver)
            enfVirus[ii] = vSol.f
            # Return reaction [ii] to it's original bounds
            HVM.reactions[ii].lower_bound = rxnLb
            HVM.reactions[ii].upper_bound = rxnUb
        # Return host bounds to original
        HVM.reactions[hostIdx].lower_bound = hostLb
        HVM.reactions[hostIdx].upper_bound = hostUb
    # True conditional
    elif usefva == True:
        # Record the host bounds
        hostLb      = HVM.reactions[hostIdx].lower_bound
        hostUb      = HVM.reactions[hostIdx].upper_bound
        #####################################
        # USERANGE #
        # Conditional: Median of FVA range
        if userange == False:
            for ii in range(len(HVM.reactions)):
                # Store the bounds of the reaction [ii]
                rxnLb = HVM.reactions[ii].lower_bound
                rxnUb = HVM.reactions[ii].upper_bound
                # Alter reacton [ii] bounds to match median host-derived flux from FVA: varHost[ii]
                maxFVA      = varHost[HVM.reactions[ii].id]['maximum']
                minFVA      = varHost[HVM.reactions[ii].id]['minimum']
                medianFVA   = maxFVA - ((maxFVA - minFVA) / 2)
                HVM.reactions[ii].lower_bound = medianFVA
                HVM.reactions[ii].upper_bound = medianFVA
                # Ensure the host objective is set to zero bounds
                HVM.reactions[hostIdx].lower_bound = 0
                HVM.reactions[hostIdx].upper_bound = 0
                # Record and store the virus optima
                vSol = HVM.optimize(objective_sense='maximize',solver=solver)
                enfVirus[ii] = vSol.f
                # Return reaction [ii] to it's original bounds
                HVM.reactions[ii].lower_bound = rxnLb
                HVM.reactions[ii].upper_bound = rxnUb
        # Conditional: Max / min bounds from FVA for reaction 
        elif userange == True:
            # Pass flux variability analysis results to tools.rangeCalculator
            (enfVirus, maxEnfBound, minEnfBound) = tools.rangeCalculator(HVM,hostIdx,virusIdx,solver)
        # Return host bounds to original
        HVM.reactions[hostIdx].lower_bound = hostLb
        HVM.reactions[hostIdx].upper_bound = hostUb
        #####################################
    #####################################
    # [3] Outputs
    return (enfVirus,maxEnfBound,minEnfBound)
###############################################################################
